
import { jsPDF } from "jspdf";
import JSZip from "jszip";
import { PDFData, MediaItem, FileType, ExportFormat } from "../types";

export const generatePDF = (data: PDFData): void => {
  // LANDSCAPE ORIENTATION (Horizontal)
  const doc = new jsPDF({ orientation: 'landscape' });
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const maxLineWidth = pageWidth - margin * 2;

  let yPosition = 20;

  // Title
  doc.setFont("helvetica", "bold");
  doc.setFontSize(22);
  doc.setTextColor(33, 33, 33);
  const titleLines = doc.splitTextToSize(data.title, maxLineWidth);
  doc.text(titleLines, margin, yPosition);
  yPosition += titleLines.length * 10 + 10;

  // Image (if available)
  if (data.imageUrl) {
    try {
      const imgProps = doc.getImageProperties(data.imageUrl);
      
      // Calculate dimensions to fit in landscape
      // Constrain by height first since landscape has less height
      const maxHeight = pageHeight - yPosition - margin;
      let imgHeight = (imgProps.height * maxLineWidth) / imgProps.width;
      let imgWidth = maxLineWidth;

      if (imgHeight > maxHeight) {
        imgHeight = maxHeight;
        imgWidth = (imgProps.width * imgHeight) / imgProps.height;
      }
      
      if (yPosition + imgHeight > pageHeight) {
        doc.addPage();
        yPosition = 20;
      }
      
      doc.addImage(data.imageUrl, "JPEG", margin, yPosition, imgWidth, imgHeight, undefined, 'FAST');
      yPosition += imgHeight + 15;
    } catch (e) {
      console.warn("Could not add image to PDF", e);
    }
  }

  // Content Body
  doc.setFont("helvetica", "normal");
  doc.setFontSize(12);
  doc.setTextColor(60, 60, 60);

  const contentLines = doc.splitTextToSize(data.content, maxLineWidth);
  
  contentLines.forEach((line: string) => {
    if (yPosition > pageHeight - margin) {
      doc.addPage();
      yPosition = 20;
    }
    doc.text(line, margin, yPosition);
    yPosition += 7;
  });

  // Footer
  const pageCount = doc.getNumberOfPages();
  for(let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(10);
    doc.setTextColor(150, 150, 150);
    doc.text(`Generated by AI PDF Studio - Page ${i} of ${pageCount}`, margin, pageHeight - 10);
  }

  doc.save(`${data.originalFileName.split('.')[0]}_report.pdf`);
};

export const generateUniversalExport = async (items: MediaItem[], format: ExportFormat): Promise<void> => {
  
  // --- PDF EXPORT (HORIZONTAL / LANDSCAPE) ---
  if (format === 'PDF') {
    const doc = new jsPDF({ orientation: 'landscape' });
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    
    for (let index = 0; index < items.length; index++) {
      const item = items[index];
      if (index > 0) doc.addPage();

      if ((item.type === FileType.IMAGE || item.type === FileType.VIDEO) && item.previewUrl) {
        // IMAGE/VIDEO MODE - FRAMELESS / FULL BLEED LANDSCAPE
        try {
          const imgData = item.previewUrl;
          const imgProps = doc.getImageProperties(imgData);
          
          // Fit Logic for Landscape
          // We want to fill the page as much as possible while maintaining aspect ratio
          let imgWidth = pageWidth;
          let imgHeight = (imgProps.height * imgWidth) / imgProps.width;

          // If height overflows (common in landscape), scale by height instead
          if (imgHeight > pageHeight) {
            imgHeight = pageHeight;
            imgWidth = (imgProps.width * imgHeight) / imgProps.height;
          }

          // Center the image
          const x = (pageWidth - imgWidth) / 2;
          const y = (pageHeight - imgHeight) / 2;
          
          doc.addImage(imgData, "JPEG", x, y, imgWidth, imgHeight, undefined, 'NONE');
          
          // Optional: Add a subtle label for video
          if (item.type === FileType.VIDEO) {
             doc.setFillColor(0, 0, 0);
             doc.rect(x + 10, y + imgHeight - 20, 40, 10, 'F');
             doc.setTextColor(255, 255, 255);
             doc.setFontSize(8);
             doc.setFont("helvetica", "bold");
             doc.text("VIDEO FRAME", x + 12, y + imgHeight - 13);
          }

        } catch (e) {
          doc.text("Could not render media item.", 10, 20);
        }
      } else {
        // NON-IMAGE CONTENT (Standard Layout)
        const margin = 15;
        const yStart = 35;

        // Header
        doc.setFont("helvetica", "bold");
        doc.setFontSize(14);
        doc.setTextColor(50, 50, 50);
        const headerText = `File: ${item.file.name} (${index + 1}/${items.length})`;
        doc.text(headerText, margin, 20);

        if (item.textContent) {
            // TEXT MODE
            doc.setFont("courier", "normal");
            doc.setFontSize(10);
            doc.setTextColor(0, 0, 0);
            const splitText = doc.splitTextToSize(item.textContent.substring(0, 3000), pageWidth - margin * 2);
            doc.text(splitText, margin, yStart);
            if (item.textContent.length > 3000) {
            doc.setTextColor(150, 0, 0);
            doc.text("... (Content truncated for PDF preview)", margin, yStart + (splitText.length * 4) + 10);
            }
        } else {
            // BINARY/UNKNOWN
            doc.setFont("helvetica", "normal");
            doc.setFontSize(12);
            doc.setTextColor(100, 100, 100);
            doc.text(`File Type: ${item.extension.toUpperCase()}`, margin, yStart);
            doc.text(`Size: ${(item.file.size / 1024).toFixed(2)} KB`, margin, yStart + 10);
            doc.text("This file is attached to the collection.", margin, yStart + 20);
        }
        
        // Footer for non-images
        doc.setFont("helvetica", "normal");
        doc.setFontSize(8);
        doc.setTextColor(180, 180, 180);
        doc.text(`AI Universal Converter - ${new Date().toLocaleDateString()}`, margin, pageHeight - 10);
      }
    }
    doc.save(`universal_export_${new Date().getTime()}.pdf`);
    return;
  }

  // --- ZIP EXPORT ---
  if (format === 'ZIP') {
    const zip = new JSZip();
    items.forEach(item => {
      zip.file(item.file.name, item.file);
    });
    
    const blob = await zip.generateAsync({type:"blob"});
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `collection_${new Date().getTime()}.zip`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    return;
  }

  // --- TXT EXPORT ---
  if (format === 'TXT') {
    let combinedText = "COLLECTION EXPORT\n================\n\n";
    items.forEach((item, i) => {
      combinedText += `FILE ${i+1}: ${item.file.name}\n`;
      combinedText += `TYPE: ${item.extension.toUpperCase()}\n`;
      combinedText += `SIZE: ${item.file.size} bytes\n`;
      combinedText += "----------------\n";
      if (item.textContent) {
        combinedText += item.textContent + "\n\n";
      } else {
        combinedText += "[Binary Content Not Included in Text Export]\n\n";
      }
      combinedText += "================\n\n";
    });

    const blob = new Blob([combinedText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `export_${new Date().getTime()}.txt`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    return;
  }

  // --- DOCX (HTML Helper) EXPORT ---
  if (format === 'DOCX') {
    // Creating a true DOCX client side is heavy, we use the HTML Blob method which Word opens happily
    let html = `
      <html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
      <head><meta charset='utf-8'><title>Export</title></head><body>
      <h1>Collection Export</h1>
    `;

    for (const item of items) {
      html += `<br clear=all style='mso-special-character:line-break;page-break-before:always'>`;
      html += `<h2>File: ${item.file.name}</h2>`;
      html += `<p>Type: ${item.extension}</p>`;
      
      if ((item.type === FileType.IMAGE || item.type === FileType.VIDEO) && item.previewUrl) {
         html += `<img src="${item.previewUrl}" style="max-width: 600px;" />`;
         if (item.type === FileType.VIDEO) {
            html += `<p><em>(Video Thumbnail)</em></p>`;
         }
      } else if (item.textContent) {
         html += `<pre style="background:#f0f0f0; padding:10px;">${item.textContent}</pre>`;
      } else {
         html += `<p><em>[Binary File Attached in package]</em></p>`;
      }
    }

    html += "</body></html>";
    
    const blob = new Blob(['\ufeff', html], {
        type: 'application/msword'
    });
    
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `export_${new Date().getTime()}.doc`; // .doc often opens easier with HTML content than .docx
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    return;
  }
};

export const generateSimpleGalleryPDF = async (items: MediaItem[]): Promise<void> => {
  await generateUniversalExport(items, 'PDF');
};
